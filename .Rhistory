import os
import leafmap
from samgeo import SamGeo, tms_to_geotiff, get_basemaps
m = leafmap.Map(center=[29.676840, -95.369222], zoom=19)
m.add_basemap("SATELLITE")
m
import os
import leafmap
from samgeo import SamGeo, tms_to_geotiff, get_basemaps
m = leafmap.Map(center=[29.676840, -95.369222], zoom=19)
m.add_basemap("SATELLITE")
m
if m.user_roi_bounds() is not None:
bbox = m.user_roi_bounds()
else:
bbox = [-95.3704, 29.6762, -95.368, 29.6775]
image = "satellite.tif"
tms_to_geotiff(output=image, bbox=bbox, zoom=20, source="Satellite", overwrite=True)
)
sam = SamGeo(
model_type="vit_h",
checkpoint="sam_vit_h_4b8939.pth",
sam_kwargs=None,
)
sam
mask = "segment.tif"
sam.generate(
image, mask, batch=True, foreground=True, erosion_kernel=(3, 3), mask_multiplier=255
)
conda create -n gee python=3.10
conda activate gee
reticulate::repl_python()
<<<<<<< HEAD
reticulate::repl_python()
=======
### temp doc for developing the work flow
pacman::p_load(dplyr,terra,sf, readr, stringr, tidyr, tmap, glcm, raster)
tmap_mode("view")
data <- list.files("data/testFeatures", all.files = TRUE, full.names = TRUE,recursive = TRUE)
n1 <- rast(data[1])
names(n1) <- c("r", "g","b","n")
# silly stuff to prep the test input data ---------------------------------
p1 <- read_csv(data[4]) |>
select(WKT) |>
pull() |>
str_remove_all("POINT ")|>
str_remove_all("[()]") |>
str_replace_all(pattern = " ", replacement = ", ") |>
data.frame()
ndvi <- createNDVI(n1)
createNDVI <- function(raster){
# (NIR - R) / (NIR + R)
r1 <- (raster$n - raster$r) / (raster$n + raster$r)
}
### temp doc for developing the work flow
pacman::p_load(dplyr,terra,sf, readr, stringr, tidyr, tmap, glcm, raster)
tmap_mode("view")
data <- list.files("data/testFeatures", all.files = TRUE, full.names = TRUE,recursive = TRUE)
n1 <- rast(data[1])
names(n1) <- c("r", "g","b","n")
# silly stuff to prep the test input data ---------------------------------
p1 <- read_csv(data[4]) |>
select(WKT) |>
pull() |>
str_remove_all("POINT ")|>
str_remove_all("[()]") |>
str_replace_all(pattern = " ", replacement = ", ") |>
data.frame()
data
# silly stuff to prep the test input data ---------------------------------
p1 <- read_csv(data[4])
p1
# silly stuff to prep the test input data ---------------------------------
p1 <- read_csv(data[4]) |>
select(WKT) |>
pull() |>
str_remove_all("POINT ")|>
str_remove_all("[()]")
# silly stuff to prep the test input data ---------------------------------
p1 <- read_csv(data[4]) |>
dplyr::select(WKT) |>
pull() |>
str_remove_all("POINT ")|>
str_remove_all("[()]") |>
str_replace_all(pattern = " ", replacement = ", ") |>
data.frame()
names(p1) <- "vals"
p1 <- p1 |>
tidyr::separate( col = "vals", sep = ", ", into = c("x", "y"))|>
mutate(x = as.numeric(x),
y = as.numeric(y))
qtm(p1)
p1
p2 <- sf:: st_as_sf(x = p1, coords = c("x","y"), dim = "XY") |>
mutate(presence = 1)
qtm(p2)
a1 <- read_csv(data[3])|>
select(WKT) |>
pull() |>
str_remove_all("POINT ")|>
str_remove_all("[()]") |>
str_replace_all(pattern = " ", replacement = ", ") |>
data.frame()
a1 <- read_csv(data[3])|>
dplyr::select(WKT) |>
pull() |>
str_remove_all("POINT ")|>
str_remove_all("[()]") |>
str_replace_all(pattern = " ", replacement = ", ") |>
data.frame()
names(a1) <- "vals"
a1 <- a1 |>
tidyr::separate( col = "vals", sep = ", ", into = c("x", "y"))|>
mutate(x = as.numeric(x),
y = as.numeric(y))
a2 <- sf:: st_as_sf(x = a1, coords = c("x","y"), dim = "XY") |>
mutate(presence = 0)
qtm(a2)
points <- bind_rows(p2,a2)
createNDVI <- function(raster){
# (NIR - R) / (NIR + R)
r1 <- (raster$n - raster$r) / (raster$n + raster$r)
}
createNDVI <- function(raster){
# (NIR - R) / (NIR + R)
r1 <- (raster$n - raster$r) / (raster$n + raster$r)
}
# slow so for now only running on the green band
## test at smaller areas to figure out a realistic run time
createGLCM <- function(band){
vals <- glcm(band,
window = c(3, 3),
statistics =
c("entropy",
"second_moment",
"correlation")
)
}
ndvi <- createNDVI(n1)
# generate a multiband feature  -------------------------------------------
n2 <- c(n1, NDVI)
n2
# generate a multiband feature  -------------------------------------------
n2 <- c(n1, ndvi)
n2
plot(n2)
# extract values ----------------------------------------------------------
v2 <- terra::extract(x = n2, y = vect(points))
v2
qtm(points) + qtm(ndvi)
# extract values ----------------------------------------------------------
v2 <- terra::extract(x = n2, y = vect(points))
# extract values ----------------------------------------------------------
v2 <- terra::extract(x = n1, y = vect(points))
v2
plot(v2)
qtm(v2)
class(v2)
?extract
values(n2$r[1:100])
values(n2$r)
# extract values ----------------------------------------------------------
v2 <- terra::extract(x = n1, y = vect(points),)
v2
# extract values ----------------------------------------------------------
v2 <- terra::extract(x = ndvi, y = vect(points),)
v2
qtm(points) + qtm(ndvi)
?extract
# extract values ----------------------------------------------------------
points2 <- vect(points)
v2 <- terra::extract(x = ndvi, y = points2,)
v2
crs(points)
points
n2
# extract values ----------------------------------------------------------
points2 <- vect(points) |>
terra::set.crs(ndvi)
points2
v2 <- terra::extract(x = ndvi, y = points2)
v2
v2 <- terra::extract(x = n2, y = points2)
v2
qtm(v2)
qtm(raster(ndvi))
?st_as_sf
sf::st_set_crs()
?st_set_crs
p2 <- sf:: st_as_sf(x = p1, coords = c("x","y"), dim = "XY",) |>
sf::st_set_crs(value = "4326")
p2
mutate(presence = 1)
p2 <- sf:: st_as_sf(x = p1, coords = c("x","y"), dim = "XY",) |>
sf::st_set_crs(value = 4326)
st_crs(p2)= 4326
p2
n1 <- rast(data[1]) |>
terra::project(4326)
?terra::project
n1 <- rast(data[1]) |>
terra::project("epsg:4326")
n1
names(n1) <- c("r", "g","b","n")
# silly stuff to prep the test input data ---------------------------------
p1 <- read_csv(data[4]) |>
dplyr::select(WKT) |>
pull() |>
str_remove_all("POINT ")|>
str_remove_all("[()]") |>
str_replace_all(pattern = " ", replacement = ", ") |>
data.frame()
names(p1) <- "vals"
p1 <- p1 |>
tidyr::separate( col = "vals", sep = ", ", into = c("x", "y"))|>
mutate(x = as.numeric(x),
y = as.numeric(y))
p2 <- sf:: st_as_sf(x = p1, coords = c("x","y"), dim = "XY",) |>
mutate(presence = 1)
st_crs(p2)= 4326
a1 <- read_csv(data[3])|>
dplyr::select(WKT) |>
pull() |>
str_remove_all("POINT ")|>
str_remove_all("[()]") |>
str_replace_all(pattern = " ", replacement = ", ") |>
data.frame()
names(a1) <- "vals"
a1 <- a1 |>
tidyr::separate( col = "vals", sep = ", ", into = c("x", "y"))|>
mutate(x = as.numeric(x),
y = as.numeric(y))
a2 <- sf:: st_as_sf(x = a1, coords = c("x","y"), dim = "XY") |>
mutate(presence = 0)
st_crs(a2)= 4326
points <- bind_rows(p2,a2)
createNDVI <- function(raster){
# (NIR - R) / (NIR + R)
r1 <- (raster$n - raster$r) / (raster$n + raster$r)
}
# slow so for now only running on the green band
## test at smaller areas to figure out a realistic run time
createGLCM <- function(band){
vals <- glcm(band,
window = c(3, 3),
statistics =
c("entropy",
"second_moment",
"correlation")
)
}
ndvi <- createNDVI(n1)
# generate a multiband feature  -------------------------------------------
n2 <- c(n1, ndvi)
n2
# extract values ----------------------------------------------------------
v2 <- terra::extract(x = n2, y = points)
v2
?resample
library(terra)
f <- system.file("ex/elev.tif", package="terra")
low <- rast(f)
low
?aggregate
n2_3 <- terra::aggregate(x = n2, fact = 2.5, fun = "mean")
n2_#
n2_3
n2
# factor of work is working 1 cell in all direction so the avergage of 9 cells
library(parallel)
# factor of work is working 1 cell in all direction so the avergage of 9 cells
# works in parallel which I'd like to use if possilbe.
n2_3 <- terra::aggregate(x = n2, fact = 1, fun = "mean")
# factor of work is working 1 cell in all direction so the avergage of 9 cells
# works in parallel which I'd like to use if possilbe.
n2_3 <- terra::aggregate(x = n2, fact = 2, fun = "mean")
plot(n2_3 )
plot(n2_3$r)
n2_3_3 <-terra::aggregate(x = n2, fact = 3, fun = "mean")
plot(n2_3_3$r)
plot(n2_3_3$r)
n2_3_3
111139 * terra::cellSize(n2)
111139 * n2@resolution
names(ndvi) <- ndvi
n2@ptr$set_resolution()
111139 * res(n2)
111139 * res(n2_3)
111139 * res(n3_3)
111139 * res(n2_3_3)
n2_3_3 <-terra::aggregate(x = n2, fact = 6, fun = "mean")
111139 * res(n2_3_3)
plot(n2_3_3)
names(ndvi) <- ndvi
# generate a multiband feature  -------------------------------------------
n2 <- c(n1, ndvi)
source("E:/geoSpatialCentroid/Agroforestry/testing/testingWorkflow.R", echo=TRUE)
# factor of work is working 1 cell in all direction so the avergage of 9 cells
# works in parallel which I'd like to use if possilbe.
n2_3 <- terra::aggregate(x = n2, fact = 3, fun = "mean") # cell 1 meter
111139 * res(n2_3)
n2_3_3 <-terra::aggregate(x = n2, fact = 6, fun = "mean") # cell
111139 * res(n2_3_3)
dim(n2)
dim(n2_3)
dim(n2_3_3)
pacman::p_load(dplyr,terra,sf, readr, stringr, tidyr, tmap, glcm, raster, furrr)
n2_3_3
bands(n2_3_3)
# generate GLMC on the high res features  ---------------------------------
ndvi1 <- createGLCM(band = n2_3_3$n)
n2_3_3$n
# generate GLMC on the high res features  ---------------------------------
ndvi1 <- createGLCM(band = raster(n2_3_3$n))
ndvi1
plot(ndvi1)
nlyr(n2_3_3)
# generate a multiband feature  -------------------------------------------
n2 <- c(n1, ndvi)
n2
ndvi <- createNDVI(n1)
names(ndvi) <- ndvi
ndvi
names(ndvi) <- "ndvi"
ndvi
# generate a multiband feature  -------------------------------------------
n2 <- c(n1, ndvi)
# original data is ~0.5 meters
111139 * res(n2)
# factor of work is working 1 cell in all direction so the avergage of 9 cells
# works in parallel which I'd like to use if possilbe.
n2_3 <- terra::aggregate(x = n2, fact = 3, fun = "mean") # cell 1.5 meter
111139 * res(n2_3)
n2_3_3 <-terra::aggregate(x = n2, fact = 6, fun = "mean") # cell 3 meter
111139 * res(n2_3_3)
# generate GLMC on the high res features  ---------------------------------
for(i in seq_along(nlyrs(n2_3_3)))
# generate GLMC on the high res features  ---------------------------------
l1 <- list()
for(i in seq_along(nlyrs(n2_3_3))){
l1[[i]] <- n2_3_3[i]
}
for(i in seq_along(terra::nlyr(n2_3_3))){
l1[[i]] <- n2_3_3[i]
}
# generate GLMC on the high res features  ---------------------------------
l1 <- list()
for(i in seq_along(terra::nlyr(n2_3_3))){
l1[[i]] <- n2_3_3[i]
}
l1
# generate GLMC on the high res features  ---------------------------------
l1 <- list()
for(i in seq_along(terra::nlyr(n2_3_3))){
l1[[i]] <- n2_3_3[[i]]
}
l1
seq_along(terra::nlyr(n2_3_3))
for(i in 1:nlyr(n2_3_3)){
l1[[i]] <- n2_3_3[[i]]
}
l1
?future_map
?furrr_options
d2 <- furrr::future_map(.x = l1, createGLCM )
plan(multisession, workers = 5)
d2 <- furrr::future_map(.x = l1, createGLCM )
l1
# generate GLMC on the high res features  ---------------------------------
l1 <- list()
for(i in 1:nlyr(n2_3_3)){
l1[[i]] <- raster(n2_3_3[[i]])
}
library(tictoc)
tic()
ndvi1 <- createGLCM(band = raster(n2_3_3$n))
toc()
plan(multisession, workers = 5)
tic()
d2 <- furrr::future_map(.x = l1, createGLCM )
toc()
d2
ndvi1
d3 <- lappy(d2, rast)
d3 <- lapply(d2, rast)
d3
d3 <- lapply(d2, rast) |> rast()
d3
# convert back to
d3 <- lapply(d2, rast) |> rast(., n2_3_3)
# convert back to
d3 <- lapply(d2, rast) |> rast() |> rast(n2_3_3)
d4 <- c(n2_3_3, d3)
d4
names(d4)
# slow so for now only running on the green band
## test at smaller areas to figure out a realistic run time
createGLCM <- function(band){
name <- names(band)
vals <- glcm(band,
window = c(3, 3),
statistics =
c("entropy",
"second_moment",
"correlation")
)
names(vals) <- paste0(name, names(vals))
return(vals)
}
ndvi1 <- createGLCM(band = raster(n2_3_3$n))
ndvi1
names(d4)
# slow so for now only running on the green band
## test at smaller areas to figure out a realistic run time
createGLCM <- function(band){
name <- names(band)
vals <- glcm(band,
window = c(3, 3),
statistics =
c("entropy",
"second_moment",
"correlation")
)
names(vals) <- paste0(name, names(vals))
return(vals)
}
d2 <- furrr::future_map(.x = l1, createGLCM )
d2
# slow so for now only running on the green band
## test at smaller areas to figure out a realistic run time
createGLCM <- function(band){
name <- names(band)
vals <- glcm(band,
window = c(3, 3),
statistics =
c("entropy",
"second_moment",
"correlation")
)
names(vals) <- paste0(name,"_", names(vals))
return(vals)
}
>>>>>>> 36726b9b93f6828af6d9ea5ccdac0b1a64f4e0bf
reticulate::repl_python()
